//
// Created by fengxuan on 2016/9/6.
//
#include <iostream>
#include <algorithm>
#include <set>
#include <list>
#include <string.h>

using namespace std;

class Solution {
public:
    /*
    首先，关于什么是全排列不做解释。如果一个排列为A，下一个排列为A_NEXT，那么A_NEXT一定与A有尽可能长的公共前缀。
    看具体例子，一个排列为124653，如何找到它的下一个排列，因为下一个排列一定与124653有尽可能长的前缀，
     所以，脑洞大开一下，从后面往前看这个序列，如果后面的若干个数字有下一个排列，问题就得到了解决。
    第一步：找最后面1个数字的下一个全排列。
    124653，显然最后1个数字3不具有下一个全排列。
    第二步：找最后面2个数字的下一个全排列。
    124653，显然最后2个数字53不具有下一个全排列。
    第三步：找最后面3个数字的下一个全排列。
    124653，显然最后3个数字653不具有下一个全排列。

    ------插曲：到这里相信大家已经看出来，如果一个序列是递减的，那么它不具有下一个排列。

    第四步：找最后面4个数字的下一个全排列。
    124653，我们发现显然最后4个数字4653具有下一个全排列。因为它不是递减的，例如6453，5643这些排列都在4653的后面。

    我们总结上面的操作，并总结出重复上面操作的两种终止情况：
    1：从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止
    2：如果已经没有了前一个元素，则说明这个排列是递减的，所以这个排列是没有下一个排列的。

    124653这个排列终止情况是上面介绍的第一种，从后向前比较相邻的2个元素，遇到4<6的情况停止。
    并且我们可以知道：
    1：124653和它的下一个排列的公共前缀为12(因为4653存在下一个排列，所以前面的数字12保持不变)
    2：4后面的元素是递减的(上面介绍的终止条件是前一个元素小于后一个元素，这里是4<6)

    现在，我们开始考虑如何找到4653的下个排列，首先明确4后面的几个数字中至少有一个大于4.
    4肯定要和653这3个数字中大于4的数字中(6，5)的某一个进行交换。这里就是4要和6，5中的某一个交换，很明显要和5交换，
     如果找到这样的元素呢，因为我们知道4后面的元素是递减的，所以在653中从后面往前查找，找到第一个大于4的数字，
     这就是需要和4进行交换的数字。这里我们找到了5，交换之后得到的临时序列为5643.，交换后得到的643也是一个递减序列。

    所以得到的4653的下一个临时序列为5643，但是既然前面数字变大了(4653--->5643)，
    后面的自然要变为升序才行，变换5643得到5346.
     */
    void nextPermutation(vector<int>& nums) {
        if(nums.empty()) return;

        int n = nums.size();

        for(int i = n - 2; i>= 0; --i) {
            if(nums[i + 1] > nums[i]) {
                int j = n - 1;
                for(;j > i - 1; --j)if(nums[j]>nums[i])break;
                swap(nums[i], nums[j]);
                reverse(nums.begin() + i + 1, nums.end());
                return;
            }
        }

        reverse(nums.begin(), nums.end());
        return;
    }
};

int main() {
    cout << "Hello world" << endl;

    return 0;
}
